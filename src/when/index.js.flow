// @flow

import type {DoWhen, ConstructFunction, DestructFunction} from '../_libs/createConstruct'
import type {ChainAPI} from '../_libs/createChainAPI'

type ChainFunctions<O, I> = {
  do: <P>(startFunc: ConstructFunction<O, P>) => DoWhen<O, I, P>
}

// No arguments
declare export default function when<O> (): ChainFunctions<O, O>;

// Map value
declare export default function when<O, I> (mapValue: (item: I) => O): ChainFunctions<O, I>;

// Settings
declare export default function when<O, I, P> (settings: {
  do: ConstructFunction<O, P>
}): DoWhen<O, I>;

// Map value and settings
declare export default function when<O, I, P> (mapValue: (item: I) => O, settings: {
  do: ConstructFunction<O, P>
}): DoWhen<O, I>;



// Dependencies 1
declare export default function when<O, I, D1>(
  mapValue: (item: I) => O,
  options: {
    do: (value: O, d1: D1, next: ChainAPI, ...args: any[]) => void | DestructFunction,
    and: [(state: I) => D1]
  }
): DoWhen<O, I>;

// Dependencies 2
declare export default function when<O, I, D1, D2>(
  mapValue: (item: I) => O,
  options: {
    do: (value: O, d1: D1, d2: D2, next: ChainAPI, ...args: any[]) => void | DestructFunction,
    and: [(state: I) => D1, (state: I) => D2]
  }
): DoWhen<O, I>;

// Dependencies 3
declare export default function when<O, I, D1, D2, D3>(
  mapValue: (item: I) => O,
  options: {
    do: (value: O, d1: D1, d2: D2, d3: D3, next: ChainAPI, ...args: any[]) => void | DestructFunction,
    and: [(state: I) => D1, (state: I) => D2, (state: I) => D3]
  }
): DoWhen<O, I>;
